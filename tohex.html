<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>HEX to Intel HEX Converter</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 30px;
    }
    input, textarea, button {
      display: block;
      margin-top: 10px;
      width: 600px;
      padding: 10px;
      font-size: 16px;
    }
    textarea {
      height: 250px;
    }
  </style>
</head>
<body>

  <h2>HEX to Intel HEX Converter</h2>

  <label for="input">Input hexadecimal data:</label>
  <textarea id="input" placeholder="00000000  DEADBEEF&#10;00010000  1234 89ABCDEF"></textarea>

  <button onclick="processHex()">Convert</button>

  <label for="output">Intel HEX output:</label>
  <textarea id="output" readonly></textarea>

  <script>
    function hexToInt(hexStr) {
      return parseInt(hexStr, 16);
    }

    function toHex(value, width = 2) {
      return value.toString(16).toUpperCase().padStart(width, '0');
    }

    function computeChecksum(byteArray) {
      const sum = byteArray.reduce((acc, val) => acc + val, 0);
      const checksum = (0x100 - (sum & 0xFF)) & 0xFF;
      return toHex(checksum);
    }

    function splitToBytes(hexWord) {
      const clean = hexWord.replace(/[^0-9A-Fa-f]/g, '');
      const bytes = [];
      for (let i = 0; i < clean.length; i += 2) {
        bytes.push(clean.substring(i, i + 2).padEnd(2, '0').toUpperCase());
      }
      return bytes;
    }

    function processHex() {
      const input = document.getElementById('input').value;
      const lines = input.split('\n');
      let output = '';
      let lastUpper16 = null;

      for (let line of lines) {
        if (line.trim() === '') continue;

        const parts = line.trim().split(/\s+/);
        const addressStr = parts[0];
        const fullAddress = hexToInt(addressStr);
        const upper16 = (fullAddress >>> 16) & 0xFFFF;
        const lower16 = fullAddress & 0xFFFF;

        const dataWords = parts.slice(1);
        let byteArray = [];
        dataWords.forEach(word => {
          byteArray.push(...splitToBytes(word));
        });

        if (byteArray.length === 0) continue;

        // Insert Extended Linear Address Record if upper address changed
        if (upper16 !== lastUpper16) {
          const elaBytes = [0x02, 0x00, 0x00, 0x04, (upper16 >> 8) & 0xFF, upper16 & 0xFF];
          const elaChecksum = computeChecksum(elaBytes);
          const elaLine = `:02000004${toHex(upper16, 4)}${elaChecksum}`;
          output += elaLine + '\n';
          lastUpper16 = upper16;
        }

        const byteCount = byteArray.length;
        const address = toHex(lower16, 4);
        const recordType = '00';

        const checksumBytes = [
          byteCount,
          parseInt(address.slice(0, 2), 16),
          parseInt(address.slice(2, 4), 16),
          0x00,
          ...byteArray.map(b => parseInt(b, 16))
        ];

        const checksum = computeChecksum(checksumBytes);
        const hexLine = `:${toHex(byteCount)}${address}${recordType}${byteArray.join('')}${checksum}`;
        output += hexLine + '\n';
      }

      // Add end-of-file record
      output += ':00000001FF';

      document.getElementById('output').value = output.trim();
    }
  </script>

</body>
</html>
