<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>HEX to Intel HEX Converter with + address continuation</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 30px;
    }
    input, textarea, button {
      display: block;
      margin-top: 10px;
      width: 600px;
      padding: 10px;
      font-size: 16px;
    }
    textarea {
      height: 250px;
    }
  </style>
</head>
<body>

  <h2>HEX to Intel HEX Converter (with '+' address continuation)</h2>

  <label for="input">Input hexadecimal data:</label>
  <textarea id="input" placeholder="00000000  DEADBEEF&#10;+ 1234 89ABCDEF"></textarea>

  <button onclick="processHex()">Convert</button>

  <label for="output">Intel HEX output:</label>
  <textarea id="output" readonly></textarea>

  <script>
    function hexToInt(hexStr) {
      return parseInt(hexStr, 16);
    }

    function toHex(value, width = 2) {
      return value.toString(16).toUpperCase().padStart(width, '0');
    }

    function computeChecksum(byteArray) {
      const sum = byteArray.reduce((acc, val) => acc + val, 0);
      const checksum = (0x100 - (sum & 0xFF)) & 0xFF;
      return toHex(checksum);
    }

    function splitToBytes(hexWord) {
      const clean = hexWord.replace(/[^0-9A-Fa-f]/g, '');
      const bytes = [];
      for (let i = 0; i < clean.length; i += 2) {
        bytes.push(clean.substring(i, i + 2).padEnd(2, '0').toUpperCase());
      }
      return bytes;
    }

    function processHex() {
      const input = document.getElementById('input').value;
      const lines = input.split('\n');
      let output = '';
      let lastUpper16 = null;
      let lastUsedAddress = null;
      let lastByteCount = 0;
      let addressSet = false;

      for (let line of lines) {
        if (line.trim() === '') continue;

        let parts = line.trim().split(/\s+/);
        let currentAddress;

        if (parts[0] === '+') {
          if (!addressSet) {
            alert("Error: Continuation line '+' without previous address set.");
            return;
          }
          parts.shift(); // remove '+'
          currentAddress = lastUsedAddress + lastByteCount; // increment by previous byte count
        } else {
          const addressStr = parts[0];
          currentAddress = hexToInt(addressStr);
          parts.shift();
          addressSet = true;
        }

        let dataWords = parts;
        let byteArray = [];
        dataWords.forEach(word => {
          byteArray.push(...splitToBytes(word));
        });

        if (byteArray.length === 0) continue;

        // Extended Linear Address record if upper 16 bits changed
        let upper16 = (currentAddress >>> 16) & 0xFFFF;
        let lower16 = currentAddress & 0xFFFF;
        if (upper16 !== lastUpper16) {
          const elaBytes = [0x02, 0x00, 0x00, 0x04, (upper16 >> 8) & 0xFF, upper16 & 0xFF];
          const elaChecksum = computeChecksum(elaBytes);
          const elaLine = `:02000004${toHex(upper16, 4)}${elaChecksum}`;
          output += elaLine + '\n';
          lastUpper16 = upper16;
        }

        const byteCount = byteArray.length;
        const address = toHex(lower16, 4);
        const recordType = '00';

        const checksumBytes = [
          byteCount,
          parseInt(address.slice(0, 2), 16),
          parseInt(address.slice(2, 4), 16),
          0x00,
          ...byteArray.map(b => parseInt(b, 16))
        ];

        const checksum = computeChecksum(checksumBytes);
        const hexLine = `:${toHex(byteCount)}${address}${recordType}${byteArray.join('')}${checksum}`;
        output += hexLine + '\n';

        lastUsedAddress = currentAddress;
        lastByteCount = byteCount;
      }

      output += ':00000001FF';

      document.getElementById('output').value = output.trim();
    }
  </script>

</body>
</html>
